# Copyright (c) 2013-2014 by Cisco Systems, Inc.

Introduction
============
PyAnnolib is a Python library for reading Electric Cloud's emake
(Electric Accelerator) annotation file, an XML log of what happened
during a build.

It was created by Gilbert Ramirez <gilramir@cisco.com>, and
Cisco has given permission to release this library to the open
source community under a BSD-style license (see the LICENSE file).

The source code for PyAnnolib can be found at the Electric Cloud
github community for Electric Accelerator:

https://github.com/electriccommunity/electricaccelerator

Caveats
=======
This is a work in progress. It works for the original author's
use-cases, which is building with GNU Make on Linux. Certain
fields that are used on Windows-based builds have not yet
been implemented, but can definitely be added.


Usage
=====
Because the annotation file can be huge, and your Python program
may not want or be able to store all records in memory at once,
PyAnnolib is designed to pass each Job record to your
program, one at a time. Your program may throw away the record,
or it may store it in memory, as you see fit.

If you do wish to have all records in memory at once, there is a
convenience function to do that for you.

There are sample programs in the top level directory of this
distribution so you can see how to use PyAnnolib

Importing
---------
from pyannolib import annolib

AnnotatedBuild(filename, fh=None)
----------------------------------
This class models one entire build. You can pass it a filename,
or an open filehandle:

    build = AnnotatedBuild(my_filename)
    or
    build = AnnotatedBuild(filename=None, fh=my_fh)

If you pass in a filename (as opposed to an open file handle),
AnnotatedBuild will automatically look for additional filenames with
"_1", "_2", etc., suffixes. When the annotation log file is approaching
2GB in size, emake will automatically close the first annotation file,
and create a new file, named with the same name, but with a suffix of "_1".
These files could be concatenated together to create a new XML file, like
so:
    $ cat file.xml file.xml_1 > new_file.xml

But Electric Insight automatically knows to look for the "_1" file. So,
PyAnnolib does the same.

The initialize will read the header of the annotation file.

The AnnotatedBuild has data associated with it (metrics), and contains many
Job records, which can be retreived, one at a time, via parseJobs()

In previous versions of PyAnnolib, the Metrics could only be accessed
after reading all the jobs with parseJobs(), because the Metrics are
stored at the end of the annotation file. Now, when an AnnotatedBuild
object is first instantiated, PyAnnolib will seek to the end of the file
and parse the metrics immediately. So, if you want to just read
the metrics, there is no need to use parseJobs() to read all the jobs first.

Methods:

getBuildID():
getCM():
getStart():
getProperties():
getVars():
    Retrieve these values.

getMetrics():
    Returns the hash of metrics that were recorded for the build.

getMessages():
    Returns the list of out-of-band messages that were emitted
    during the build, if any. These are available during job
    parsing, or afterwards. The Message records are interspersed
    with the Job records.

parseJobs(cb, user_data=None)

    If the annotation file has
    many thousands of Jobs and you do not with to store them all
    in memory at once, this function lets you handle each Job
    object one at aa time.

    For each Job record in the XML file, runs the callback function
    (cb), passing it that Job object and user_data. The user_data
    is any additional data that your code wishes for the callback
    function to see; it is a handy way of passing in other objects
    that the callback might need.

    The callback function will look like:

    def my_callback(job, user_data):
        # process the job objet here.


getAllJobs()

    Returns a list of all Job objects in the annotation file.
    This loads all Job objects in memory at once, so if your
    annotation file is extremely huge, you might have to worry
    about memory size here.

close()
    Closes the filehandle. If you had AnnotatedBuild open the
    filehandle for you, you may want it to close it as well.

*NOTE*

    At some point in the future a generator function might be added
    to make it easier to retrieve Job records one at a time, without
    having to use a call-back. But the current implementation of
    pyannolib uses the XML SAX parser in a way that makes it
    impossible to use 'yield' to return Job records iteratively.
    Using xml.sax.xmlreader.IncrementalParser as the XML reader
    might allow us to create a generator. But, as it is a minor nit,
    don't expect any work on this soon.

Job
---
getID()
getStatus()
getThread()
getType()
getTimings()
getMakeProcess()
getWaitingJobs()
getOutputs()
getOperations()
getCommands()
getDependencies()
getConflict()
getName()
getNeededBy()
getFile()
getLine()
getPartOf() - Used in FOLLOW-type jobs
    Retrieve these values.


MakeProcess
-----------
getLevel()
getCmd()
getCWD()
getOWD()
getMode()
    Retrieve these values.

getID() - This is an artifical ID, as it is not stored in the XML file.
    The same is used in Electric Insight

getParentJobID() - This is computed by the sequence of jobs in the XML
    file. This is the job that started this "make process"


Operation
---------
getType()
getFile()
getFileType()
getFound()
    Retrieve these values.

Timing
------
getInvoked()
getCompleted()
getNode()
    Retrieve these values.

Command
-------
getLine()
getArgv()
getOutputs()

Dependency
----------
getWriteJob()
getFile()
getType()

Conflict
--------
getType()
getWriteJob()
getFile(0
getRerunBy()

Output
------
getText()
getSrc()


Message
-------
getText()
getThread()
getTime()
getSeverity()
getCode()


PyAnnolibError - this is the exception that the library will raise
if something is amiss.

anno_open() - this routine opens an annotation file and returns
a filehandle. However, if it finds a "_1", etc., continuation file,
it creates a ConcatendatedFile object (see pyannolib/concatfile.py),
which acts like a filehandle, but automatically and seamlessly
makes multiple files look like one larger file.



Developing
==========
Read the DEVELOPMENT text file.


Sample Scripts
==============

compare-metrics - Show specified metrics between 2 anno files,
    or between the same-named anno files in 2 directories.

sample-jobs - This sample script shows a few details about the Build,
    and then shows some data for each "rule" Job that has Command
    objects associated with it. That is, these are the jobs that would
    normally appear in a Make log.

sample-metrics - shows how to read the metrics and report them.

show-errors - This shows the jobs that failed.

show-conflicts - shows the conflicting jobs in a build

show-deps - shows the file dependency graph

show-jobpath - shows the MakeProcess/Job hierarchy, like the "JobPath"
    tab in ElectricInsight
